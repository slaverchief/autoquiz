# Инструкция к пользованию

STACK: **`Django`**,  **`PostgreSQL`**,  **`Django REST Framework`**

Проект из себя представляет веб-приложение для автоматического тестирования. Приложение предлагает удобный REST API для манипуляции с данными.

## Запуск  
### Предварительные действия  
#### Переменные окружения  
Перед запуском приложения необходимо определить следующие переменные окружения:  
- **SECRET_KEY** - секретный ключ  
- **POSTGRES_DB** - название базы данных в PostgreSQL  
- **POSTGRES_USER** - имя пользователя, который имеет доступ к базе данных  
- **POSTGRES_PASSWORD** - пароль пользователя базы данных в PostgreSQL  
- **HOST** - адрес, где будет запущен сервер(то, что будет включено в `ALLOWED_HOSTS`)
- **POSTGRES_HOST** - адрес работающей базы данных PostgreSQL  
- **DEBUG** - флаг включенной или выключенной отладки(1 или 0)

**ВАЖНО:** при DEBUG=1исключения, связанные с бизнес логикой приложения, не будут обработаны и все ошибки надо будет просматривать через консоль отладки.
### Варианты запуска  
#### Обычный запуск  
Для обычного запуска достаточно ввести последовательность следующих команд в директории проекта:  
1. `pip install -r requirements.txt`  
2. `python manage.py makemigrations`  
3. `python manage.py migrate`  
4. `python manage.py runserver`  
#### Запуск через docker  
Для запуска через docker понадобится лишь создать в директории проекта файл переменных окружения **vars.env** и прописать там все необходимые переменные окружения в следующем формате:
```
SECRET_KEY='sometext'  
DEBUG=1
HOST='localhost'  
POSTGRES_DB='test-quiz'  
POSTGRES_USER='django'  
POSTGRES_PASSWORD='somepassword'  
POSTGRES_HOST='localhost'
```
Далее все запускается командой `docker-compose up` в директории проекта.
#### Создание суперпользователя
Далее можно создать суперпользователя командой:
`python manage.py createsuperuser`
Это необязательный шаг, но он будет полезен, если хочется рассмотреть приложение детальнее на странице админ-панели, на которую можно перейти по эндпоинту **/admin**.

## Импорт тестов
### Парсинг
Так как стандартно **CSV** не предоставляет функцию хранения списков, была реализована особая система парсинга: список представлен строкой вида:
`"object1|object2|object3"`
Объекты списка могут содержать любые символы, включая запятую и пробел, за исключением символа `|`

### Через командную строку
Импортировать **CSV** файл с тестами можно командой:
`python manage.py csv import {filename}`, где **filename** - это название импортируемого файла.

### Через HTML страницу
Импортировать тесты можно и через эндпоинт **/upload**:  перед вами откроется страница с формой для загрузки файла. Вы можете выбрать файл в своей файловой системе и загрузить его: если что-то пойдёт не так, вы будете уведомлены надписью под формой. 
**ВАЖНО:** загрузка через страницу доступна только суперпользователям, поэтому перед использованием этой функции нужно авторизоваться на админ-панели

## Документация
К автоматически сгенерированной документации можно попасть по эндпоинту **/swagger**.

## Эндпоинты
Здесь будут расписаны не интуитивно понятные эндпоинты, дабы описать то, как ими пользоваться. Следующее содержание написано с учетом того факта, что пользователь уже ознакомлен с документацией **swagger**.

Для дальнейшего понимания стоит учитывать, что архитектура хранения данных тестирования разделена на 3 отдельные сущности: тест, вопрос, вариант ответа. Это 3 отдельные сущности, имеющие связи между собой. Это означает, что объект каждой сущности является уникальным для своего родителя и не принадлежит кому-то ещё. Скажем, один объект вопроса принадлежит только одному объекту теста, а один объект варианта ответа принадлежит одному объекту вопроса. Данная архитектура соответствует принципам нормализации и использована во избежания хранения сложных структур данных в качестве полей в таблице.
### POST /question
```json
{
  "question": ID вопроса,
  "answers": [
  ...
    ID варианта ответа
  ...
  ]
}
```
Эндпоинт регистрирует ответ пользователя на какой-то вопрос. В теле запроса поле **question** передает идентификатор объекта вопроса(**question.id**), на который надо зарегистрировать ответ. В поле **answers**  передается список идентификаторов вариантов ответа(**choice.id**), которые можно получить по эндпоинту **[[#GET /question/{id}|/question/{id}|]]**. В приложении каждый экземпляр вопроса имеет гарантированную связь с объектом теста,  поэтому в качестве вводных данных идентификатор теста указывать не нужно. Регистрировать ответ на вопрос можно лишь один раз.

### GET /question/{id}
```json
 [
 ...
 {
    "id": ID вопроса,
    "choices": [
      ...
      {
        "id": ID варианта ответа,
        "text": "ТЕКСТ ВАРИАНТА ОТВЕТА"
      },
      ...
    ],
    "content": "ТЕКСТ ВОПРОСА",
    "type": ТИП ВОПРОСА
  }
  ...
  ]
```
Эндпоинт возвращает список вопросов, привязанных к конкретному тесту. Поле **choices** хранит список вариантов ответа на вопрос.

### GET /quiz/{id}
```json
{
  "quiz": {
    "id": ID теста,
    "name": "НАЗВАНИЕ ТЕСТА"
  },
  "questions": [
	...
    {
      "question": ID вопроса,
      "answers": [
      ...
        ID варианта ответ
      ...
      ]
    }
	...
  ]
}
```
Эндпоинт возвращает список вопросов, на которые ответил авторизованный пользователь вместе с его ответами. В списке **answers** хранятся идентификаторы вариантов ответа, которые выбрал пользователь.